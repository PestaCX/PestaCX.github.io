<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JS - Objects</title>
    <link rel="stylesheet" href="\CSS\styling.css">
</head>

<body>
    
    <div class="menuLine">
       
        <li class="nav_menu inLineMenu"><a href="index.html">&nbsp;&nbsp;Főoldal&nbsp;&nbsp;</a></li>
        <li class="nav_menu inLineMenu"><a href="HTML_ELEMEI.html">&nbsp;&nbsp;HTML&nbsp;&nbsp;</a></li>
        <li class="nav_menu inLineMenu"><a href="CSS_Tutor.html">&nbsp;&nbsp;CSS&nbsp;&nbsp;</a></li>
        <li class="nav_menu inLineMenu"><a href="about.html">&nbsp;&nbsp;about&nbsp;&nbsp;</a></li>
       
        <li class="nav_menu inLineMenu dropdown">
            <a href="javascript:void(0)" class="dropbtn">&nbsp;&nbsp;Dropdown&nbsp;&nbsp;</a>
            <div class="dropdown-content">
              <a href="#">Link 1</a>
              <a href="#">Link 2</a>
              <a href="#">Link 3</a>
          
            </div>
    </div>


    <h1> Objektumok a JavaScript-ben</h1>


    <h2 class="h2_border"> Mik azok az objektumok?</h2>

    <p>
        Az objektum olyan értékcsoport, amely egy adott tárgykör köré
        csoportosított értékeket tartalmaz. <br>
        Ezt általában arra használjuk, hogy a való életből vett objektumokat
        modellezzünk benne.
        Ezen értékek egy része megnevez egy bizonyos tulajdonságot, 
        egy másik részük pedig az erre a tulajdonságra vonatkozó értéket tárolja.
        Ez gyakorlatilag adat-párokat jelent, aminek a részeit 
        <em>key-value</em> párnak nevezzük. <br>
    </p>

    <p>
         Egy objektumnak van neve, és vannak benne key-value adat-párok
        aszerint, hogy az obejktumnak hányféle tulajdonságát tároljuk.
    </p>

    <p class="tananyag"> 
                A tananyag-beli leírás szerint:
        Az objektum - rugalmas adattárolás <br>
        Adatok tárolása kulcs-érték párok segítségével. 
        Ez az objektum. Abban a tekintetben hasonlít a tömbökre,
         hogy egy kollekció, amiben bármilyen típusú adatot tárolhatsz,
          akár tömböket vagy másik objektumokat is.
           Más programnyelvekben nem így hívják ezt az adattípust,
            de mindegyikben van megfelelője.
</p>

<p class="tananyag"> <b> key - kulcs </b><br>
Az objektumok esetén nem automatikusan indexelődnek az elemek,
 mint a tömb esetén, hanem mi határozzuk meg a kulcs-érték párokat.
A kulcsoknak minden esetben String típusúaknak kell lenniük. <br>
<b> value - érték </b><br>
A kulcsokkal jelölt értékeket tulajdonságoknak is nevezik.
 Az alábbi példában egy egyszerű objektum létrehozását láthatod.
  Figyeld meg, hogy az objektumot kapcsos zárójelek határolják,
   a kulcs-érték párokat vesszők, a kulcsot pedig kettőspont választja
    el az értéktől:
</p>

<p class="tananyag">
   <b> Object.keys() </b>  az objektum kulcsai <br>
Az objektumok esetén fontos, hogy tudd mit tárolsz bennük.
 Mivel az objektum elemeit a kulcsok segítségével éred el,
  ezért nem árt tudni, hogy milyen kulcsok vannak egy objektumban.
   Ezeket a kulcsokat pedig az Object.keys metódus adja vissza.
Az Object.keys metódus tömb formában adja vissza a kapott objektum
 kulcsait.
Az objektum tulajdonságait úgy tudod elérni, hogy az objektum neve után
 ponttal elválasztva megadod a kiválasztott tulajdonság kulcsát,
  vagy szögletes zárójelek között  [ ] String -ként adod meg:
</p>

<p class="tananyag">
    <b> Az objektum hossza </b> <br>
    Az objektumoknak nincs length tulajdonsága, mint a tömböknek,
     ezért más módszerhez kell folyamodnod, ha szeretnéd megtudni
      az elemeiknek a számát. Erre a legegyszerűbb módszer, ha 
      nem az elemeiket, hanem a kulcsaikat számolod meg.
    Figyelem: a példában láncolt metódus hívást alkalmazunk.
    Ennek lényege, hogy egy függvény által visszaadott típusra
     azonnal meghívod annak szabványos metódusát vagy lekéred egy 
     adott tulajdonságát, jelen esetben a tömb elemeinek számát,
      azaz a tömb hosszát. <br>
    Az Object.keys tömböt ad vissza, majd annak le is kérheted
     azonnal a length tulajdonságát:

</p>

    <h2 class="h2_border"> Objektum megadásának módja</h2>
    <p>Megadásuk egyik módja a következő:</p>

    <div class="code_snippet">
        objectName = { <br>
            &nbsp;&nbsp;&nbsp;&nbsp; key1 : value1, <br>
            &nbsp;&nbsp;&nbsp;&nbsp; key2 : value2, <br>
            &nbsp;&nbsp;&nbsp;&nbsp; key3 : value3, <br>
            &nbsp;&nbsp;&nbsp;&nbsp; .  <br> 
            &nbsp;&nbsp;&nbsp;&nbsp; . <br>
            &nbsp;&nbsp;&nbsp;&nbsp; keyx : valuex, <br>
        };
        <p class="comment">
            /Megadjuk az objektum nevét, és annak elemeit.
            Az elemeket kapcsos zárójelben. <br>
            /A key-value párokat a felsorolásban vessző választja el,
             míg a key-t a value-tól kettősponttal választjuk el.
        </p>
    </div> <br>

    <p>Ugyanez, kicsit életszagúbb példával:</p>

    <div class="code_snippet">
        autó = { <br>
            &nbsp;&nbsp;&nbsp;&nbsp; gyártmány : "Daewoo", <br>
            &nbsp;&nbsp;&nbsp;&nbsp; modell : "Matiz", <br>
            &nbsp;&nbsp;&nbsp;&nbsp; évjárat : 2000, <br>
            &nbsp;&nbsp;&nbsp;&nbsp; szín :  "arany",  <br> 
            &nbsp;&nbsp;&nbsp;&nbsp; km : 59100 <br>
        };
        <p class="comment">
            /Van tehát egy Daewoo Matiz autónk, ami 2000-es évjáratú,
            aranyszínű, és 59100km van benne.
        </p>
    </div>
    <p> Ezzel tehát létrehoztunk egy "autó" nevű objektumot.</p>
    
    <p>A fenti megadási módozat akkor jó, ha kapásból adatokat is 
        adunk meg az objektum létrehozásával együtt. 
    </p>
    <br>

    <p>
         Ennek az obejktumnak az elemeire többféleképpen is hivatkozhatunk:
    </p>
    
    <div class="code_snippet">
        autó.gyártmány  <span class="comment"> vagy </span>autó[gyártmány]<span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/= Daewoo</span> <br>
        autó.modell <span class="comment"> vagy </span> autó[modell]<span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/= Matiz</span> <br>
        autó.évjárat <span class="comment"> vagy </span> autó[évjárat]<span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/= 2000</span> <br>
        autó.szín <span class="comment"> vagy </span> autó[szín] <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/= arany</span> <br>
        autó.km <span class="comment"> vagy</span> autó[km] <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/= 59100</span> <br>
    
        
    </div>

    <br>

    <p>
        De arra is van lehetőségünk, hogy "üres" objektumot hozzunk létre.
        Ezt az objektum-konstruktorral tehetjük meg, kétféle megadási 
        módja van:
    </p>

    <div class="code_snippet">

        <p> let user = new Object(); <span class="comment">/Szigorúan nagy "O"-val írandó az object!</span> </p>

        <snap class="comment">/ Ennek van egy még egyszerűbb módja:</snap>  

        <p>let user = {};</p>

    </div>


    <br>

    <p>
        Az objektumok ezen használatának módja azért előnyös, 
        mert így az egy objektumhoz tartozó adatok egy csoportban vannak,
        nincsenek szanaszét, rendezetlenül.
    </p>

    <br>








    <p>
       Az objektum gyakorlatilag hivatkozás egy adatcsoportra.
       Ez összhangban áll azzal, miszerint ha a függvény objektumot kap
       argumentumként, akkor a függvény a teljes objektumot átadja, nem csak
       az objektum elemeinek másolatát. <br>
       (Ezzel jó vigyázni, mert ebben a vonatkozásban a sima változók
       és az objektumok máshogyan viselkednek a függvényekkel!) <br>
       Ez valószínűleg azért van így, mert egy objektum sok al-adatot
       tartalmazhat, és az objektumon dolgozó függvény hívásakor egyáltalán 
       nem biztos, hogy mindegyik al-adat kell a függvénynek. <br>
       Azt azonban simán el tudom képzelni, hogy ha egy objektum egy 
       bizonyos elemére hivatkozva hívok egy függvényt, akkor ott csak az
       adott érték másolata kerül át a függvénybe - de ezt majd kipróbáljuk!
     <br>
       Vagyis az objektum olyan, mint egy címke (azonosító) alatti változók
       gyűjteménye. <br>
       A további változóknak van neve (key), és van értéke (value).
       Valószínűleg ezt hívják asszociatív tömbnek - összerendelt tömbnek.
       (Utánaolvastam a stackoverflow-n, és tényleg! :-) )
    </p>

    <h2 class="h2_border">A for ... in ciklus <span class="code_snip">/ for (keyvariable in objectName)</span> </h2>
    <p>
         Erre azért van szükség, mert a sima tömbökkel ellentétben
         az objektumoknak nincs length tulajdonsága ( <span class="code_snip">Array.length</span>  létezik, de <span class="code_snip">Object.length</span> nincs.). Emiatt pedig ily
         módon nem tudjuk a hosszát meghatározni, ebből következően 
         a hagyományos iterációs ciklust nem tudjuk rá alkalmazni.
    </p>

    <div class="code_snippet">
        <b>for</b> (let k <b>in</b> user) {   <span class="comment"> / ahol user egy objektum<object data="" type=""></object></span> <br>
            &nbsp;&nbsp;&nbsp;&nbsp;console.log("Key:", k, "Value:", user[k]); <br>
        }

    </div>

    <p>
        A fenti formula először kiolvassa a <b> kulcsokat,</b> majd azokra 
        hivatkozva kiolvassa a hozzájuk tartozó értékeket.  <br>
         A kulcsok ugye 
        elsősorban string-típusúak lehetnek az objektumok esetében. <br>
        Ugye "k" itt egy változó. Az <span class="code_snip">object.key</span>  formájú megadásból kiindulva a "key"
        egy string, de nem egy változó.
        Ha nincs "k" nevű(!) kulcs az objektumban, akkor a <span class="code_snip">user.k</span>  
        megadás nem fog működni.
        A <span class="code_snip"> user[k] </span>azonban igen - a k idézőjel nélkül, változói minőségében van itt!
        <br>
        Ez a fajta for ... in ciklus tömbökkel is működik! <br>
        Mégpedig azért, mert a tömb a string-ként reprezentált 
        index-változót (ami egyébként egy szám, ugyebár...) is
         számként értelmezi! (Számunkra kedvező módon.) <br>
        Ebből következik, hogy a for ... in ciklus univerzálisan használható
         az objektumok és a tömbök esetén is!
         <br>
         <span class="x">
         (Érdemes egy kicsit elgondolkodni azon, hogy amint leírunk egy 
         számjegyet, abban a pillanatban string-et látunk. Az adott <em> számjegy </em>
         tehát egy string. A <em>szám</em> az általa reprezentált számérték.)
        </span>
    </p>

    <h2 class="h2_border">A for ... of ciklus</h2>
    <p>
         Ez a for ... in ciklussal ellentétben nem a <em> kulcsokon</em> lépked,
         hanem az <em>értékeken</em> lépked végig. <br>
         Pl. egy string-en is képes végigmenni. :-) <br>
         
    </p>


    <p class="doubt">
        Ezt a for...in és for...of közötti különbséget át kell nézni.
        Ugyanis a tananyag szerint az objektum nem iterálható. <br>
        Az iterálhatóság azt jelenti, hogy van egy meghatározott illetve
        meghatározható sorrend,
        ami alapján az elemeken végig lehet menni. <br>
        A leírások szerint a for...of az iterálható sorozatok esetében használatos. <br>
        Tömb esetében egyszerű a dolog, mert ott minden egyes elemnek van
        egy indexe, ami gyakorlatilag az elem sorszáma. <br>
        Az objektum esetében azonban nincs ilyen. <br>
        Amit nem értek: mi szükség van rá? Hiszen a for...in szépen végiglépked
        a kulcsokon, amikhez egyértelműen hozzá van rendelve 1-1 érték. <br>
        És ha már a for...in végig tud lépkedni, akkor mi alapján teszi? És
        miért nem tudja ugyanezen az alapon a for...of? <br>
        És miért nevezi "igen okos"-nak a for...of ciklust? Hiszen csak
        akkor működik objektummal, ha az objektum entries-re vagy keys, vagy
        values-re indítom el a ciklust.
    </p>

</body>
</html>